# Portaled Workflow Proposal

## Reminders

* Need inert for accessibility, focus trap has problems
* Replay focus on launch point for portaled contents

## Portal Components

1. Modal (Modal Manager)
2. Popup (Hookshot, Select(?), Date Picker)
3. Notification Dialog
4. Blocking Overlay
5. Framework Dialog

## Z-Index Ranges

  0 ----------> 1000 ------------------> 2000 -------------------> 3000 --------------> 4000
(Root)         (Modal)           (Notification Dialog)      (Blocking Overlay)    (Framework Dialog)

## Types of Portaled Elements

1. Fixed
  * Element presents at a fixed z-index. Framework logic is in place to prevent duplicate presentation (layered elements).
  * Components include: Blocking Overlay, Notification Dialog, Framework Dialog
2. Relative
  * Element presents at a dynamic z-index relative to and higher than a parent portal, resulting in a layered display
  * Components include: Modal, Popup

## Component Deep Dives

### Modal

Type: Relative (min 1000)

Intended Usage:

The Modal component allows a component to present modal content within the same component context.
The Modal is considered an extension of the content that renders it, not a wholly separate entity.
managed by the framework. The removal of the presenting component will result in the dismissal of the presented Modal.
Modal presentation should be reproducible and originate from user interaction, not automatically from async actions.

Features:

* Always closes on escape key press
* Never closes on outside click
* Always includes ActionHeader with modalTitle and close button (executing onRequestClose callback)
* Always includes ActionFooter with 'Close' button (executing onRequestClose callback)
* Provides z-index context for nested portal content
* Modals presented within a Modal will result in stacked modal presentation
* Subsequent Modals presented at the same index will be automatically closed
* NavigationPrompt integration with close actions
* Content within modal is functionally equivalent to root level content and can render the same components without issue

API:

```jsx
<Modal
  modalTitle={'Example Title'}  // doubles as aria-label (?)
  role="dialog"                 // might be able to default this
  size={'TBD'}                  // Size API from disclosure API, or something new?
  isOpen={modalIsOpen}
  onRequestClose={() => {
    setModalIsOpen(false);
  }}
>
  <div>Modal Content</div>
</Modal>
```

Outstanding Questions:

* How do we handle the display of notification banners within these content-driven modals?
* How do we get global modal banners (like the Demographics banner) injected into this content-driven modal?
  * We could have a separate context that components can provide with a banner, any Modals open within that context present the content.
  * Need to investigate more with what Matt's talked about with a more generic "Concept" context.
* Would we need additional props for additional header/footer actions?
  * I'm assuming this is yes, but left them out for the time being.
  * Footer actions get interesting when combined with the default Close button.

Benefits:

* One modal to rule them all
* Greatly simplified modal experience for our consumers
* Strict enforcement of UX/accessibility standards for modals
* Context chain is persisted

Drawbacks:

* Divergent from existing ModalManager design

### Popup

Type: Relative (min 0)

Intended Usage:

The Popup component's intended usage is very similar to that of the Modal. The Popup should be used
to present transient, positioned content.

Features:

* Always close on escape
* Always close on outside click
* Positions z-index relative to parent portals
* Does not provide z-index context for nested portal content. Popup is a portal endstate.
* Subsequent Popups presented at the same index will be automatically closed

### Notification Dialog

Type: Fixed (2000)

Intended Usage:

The Notification Dialog shows a modal view with a restricted presentation API.

Users call an imperative API to add data to a queue. Notification Dialogs are presented with data from that queue until the queue is
empty. This prevents multiple dialogs from being presented at any given time.

Features:

* Never close on escape
* Never close on outside click
* Does not provide z-index context for nested portal content. Notification Dialog is a portal endstate.
* Always includes header/footer with fixed actions.

API:

```jsx
// custom hook to assign id's/cleanup dialogs automatically when presenter components unmount
// Class components could call global methods directly, but they'd have more work to do to clean up
const useNotifications = () => {
  const idRef = useRef(uuidv4());

  useEffect(() => () => {
    // Cleanup on unmount if they're still hanging around
    TerraApplication.notifications.removeDialog(idRef.current);
  })

  const notificationsAPI = useMemo(() => ({
    showDialog: (options) => {
      return TerraApplication.notifications.showDialog({ ...options, id: idRef.current });
    }
  }), [])

  return notificationsAPI;
}

const ExampleComponent = () => {
  const notifications = useNotifications();

  const submitRequest = () => { /* do the thing */ };

  const onFormSubmit = async () => {
    const userSelection = await notifications.showDialog({
      variant: 'warning',
      startMessage: 'Are you sure you want to do that?',
      buttonOrder: 'acceptFirst',                         // We can probably default this globally somehow
      acceptActionText: 'Yes',                            // Likely have defaults for this text as well. Ideally the consumer would only 
      rejectActionText: 'No',
    });
    
    if (userSelection === 'accept') {
      submitRequest();
    }
  }

  return (
    <button onClick={onFormSubmit}>Submit</button>
  );
}
```

Outstanding Questions:

* Would the queue order need to be managed/manipulated based on notification type (error > warning)?
* What types of custom content do we need to support? Popups/selects?
* Do we truly need to support custom variants or can we lock this down?

Benefits:

* More control over presentation and display of application notifications
* Rigid styling to enforce UX/accessibility patterns

Drawbacks:

* Context chain is not persisted, unlike today. Depending on the custom content requirements, this might not be a big deal.
* Imperative API isn't typical React

### Blocking Overlay

Type: Fixed (3000)

Intended Usage:

The Blocking Overlay is an overlay component used to block user input into the application. The Blocking Overlay covers the entirety of the application,
including all portaled content (besides the Framework Dialog).

Blocking Overlay presentation should be originate from user interaction, not present automatically from async actions. Usage should generally be discouraged
in favor of scratchpad/non-junk service usage.

Features:

* Never close on escape
* Never close on outside click (what outside click)
* Does not provide z-index context for nested portal content. Blocking Overlay is a portal endstate.
* Includes timeout logic to allow user to dismiss overlay after period of time

API:

```jsx

const cancelablePromise = (promise) => {
  let isCanceled = false;

  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then((val) => {
      if (isCanceled) {
        reject({ isCanceled: true }); 
        return;
      }

      resolve(val);
    });

    promise.catch(error) => {
      if (isCanceled) {
        reject({ isCanceled: true }); 
        return;
      }

      reject(error);
    }
  });

  return {
    promise: wrappedPromise,
    cancel: () => { isCanceled = true; }
  }
}

const ExampleComponent = () => {
  const [isSaving, setIsSaving] = useState(false);
  const saveRequestRef = useRef();

  function cleanupLongRequest() {
    setIsSaving(false);
    if (saveRequestRef.current) {
      saveRequestRef.current.cancel();
      saveRequestRef.current = undefined;
    }
    // Work on fixing services
  }

  function startSaving() {
    setIsSaving(true);

    saveRequestRef.current = cancelablePromise(saveRequest());
    
    saveRequestRef.current.promise.then(() => {
      setIsSaving(false);
      saveRequestRef.current = undefined;
    }).catch((error) => {
      setIsSaving(false);
      saveRequestRef.current = undefined;

      if (error?.isCancelled) { return; }

      console.error('Yo something broke');
    })
  }

  return (
    <div>
      <BlockingOverlay
        isOpen={isSaving}
        timeoutMessage="This sure is taking a while. Cancel?"
        timeoutButtonText="Cancel"
        onTimeout={() => {
          cleanupLongRequest();
        }}
      />
      <button onClick={startSaving}>Save</button>
    </div>
  )
}

// OR

const useBlockingOverlay = () => {
  const idRef = useRef(uuidv4());
  const cleanupRef = useRef();

  const api = useMemo(() => ({
    show: (promise, options) => {
      const wrappedPromise = cancelablePromise(promise);

      TerraApplication.blockingOverlay.show(idRef.current, options, wrappedPromise.cancel);

      cleanupRef.current = () => {
        wrappedPromise.cancel();
        TerraApplication.blockingOverlay.hide(idRef.current);
      };

      return {
        promise: wrappedPromise.promise.then((val) => {
          TerraApplication.blockingOverlay.hide(idRef.current);
          cleanupRef.current = undefined;

          return val;
        }).reject((error) => {
          TerraApplication.blockingOverlay.hide(idRef.current);
          cleanupRef.current = undefined;

          return error;
        }),
        cancel: () => {
          wrappedPromise.cancel();
          TerraApplication.blockingOverlay.hide(idRef.current);
          cleanupRef.current = undefined;
        },
      };
    },
  }), []);

  useLayoutEffect(() => () => {
    if (cleanupRef.current) {
      cleanupRef.current();
    }
  }, []);

  return api;
}

const ExampleComponent = () => {
  const [isSaving, setIsSaving] = useState(false);
  const blockingOverlay = useBlockingOverlay();

  function startSaving() {
    setIsSaving(true);

    blockingOverlay.show(saveRequest(), {
      timeoutMessage="This sure is taking a while. Cancel?"
      timeoutButtonText="Cancel"
    }).promise.then(() => {
      setIsSaving(false);
      // refresh or something
    }).catch((error) => {
      setIsSaving(false);
      saveRequestRef.current = undefined;

      if (error?.isCancelled) { return; }

      console.error('Yo something broke');
    });
  }

  return (
    <div>
      <button onClick={startSaving}>Save</button>
    </div>
  );
}
```

### Framework Dialog

Type: Fixed (4000)

Intended Usage: 

The Framework Dialog is functionally and visually very similar to the Notification Dialog. The biggest difference between the two
are consumer access. Only terra-application/orion-application may present a Framework Dialog, and even then in very specific circumstances.
Primary use case I can think of right now is the pending lock dialog that we wish to present. 

The Framework Dialog would have the highest z-index and present over all other portaled contents, including the Blocking Overlay.

API:

Similar to Notification Dialog, just entirely local to a framework component.

# Composition Layers

ApplicationBase
  - Ideally no DOM added here, just context/API
ApplicationContainer
  - AppConcept banner/content
  - More than one (ApplicationContainer, NavigationApplicationContainer, EmbeddedApplicationContainer)
PageContainer
  - Defines presentation region for Pages
  - More than one (PageContainer, NavigationPageContainer)
Page
  - Fundamental concept for composable application design
  - Can be presented within Modal (Page API is subset of Modal API)
Modal
  - Superset of Page API + modal specific API (foot actions)
  - Can be presented from any layer within ApplicationBase

ApplicationBase
  ApplicationContainer
    PageContainer
      Page

# TODO

* Application Concept
  * (X) Prototype implementation
  * (X) Determine ideal placement locations
    * The concept will be rendered by the Application Variants (Navigation/Embedded)
  * Define API for specifying page/modal concept banners (are they the same? are they different?)
* ApplicationPage
  * (X) Prototype implementation
  * (X) Investigate scroll position replay
  * (X) Move 'main' to Page
  * (X) Investigate NotificationBanner integration
  * (X) Breadcrumbs prototype
  * Investigate accessibility impact
  * Determine actions API
  * Better Back button?
  * Hide header for embedded workflows?
* PageContainer
  * (X) Prototype implementation
  * Workspace region (resizable)
* SideNavigationPageContainer
  * (X) Prototype implementation
  * Determine side nav API/data persistance expectations
  * Determine default side nav design
* ApplicationModal
  * (X) Prototype implementation
  * (X) Investigate NotificationBanner integration
  * (X) Consume Application Concept API
  * Determine stacking patterns (stack or hide previous)
  * Inert implementation
    * If we hide the previous modals, inert isn't necessary beyond base level content
  * Determine sizing API
  * Determine header/footer actions API
    * This should match the ApplicationPage's action API if we want to integrate
* Notification Dialog
  * Prototype implementation
  * Investigate imperative API implementation
  * Investigate dialog queue
* Notification Banner
  * (X) Prototype implementation
* Blocking Overlay
  * (X) Prototype implementation
  * Investigate multi-phase presentation
  * Investigate duplicate calls
  * Fix inert implementation for modal/other layer integration
* Framework Dialog
  * Prototype implementation
* Session Provider (orion-application)

TODO 7/2
* (X) PageHeader actions dropdown
* (X) PageHeader actions launch Popup
* Accordion Side Navigation
* (X) Full mounts for Primary/Side Nav pages

TODO 7/9
* (X) PageContainers in modals 
* (X) Modal header separate from page header
* Page-in-modal accessibility (main in modal => bad news bears)
* (X) Performance investigation
  * Mainstream websites average ~150MB-200MB heap size
  * terra-ui ~10MB
  * Demo running in dev site ~10MB
  * Demo with 100 side nav pages ~20MB (spikes to ~45)
  * Demo with 1000 side nav pages ~150MB (spikes to ~250) (noticeable performance degradation due to huge side nav list)
* Accordion Side Navigation
* (X) Review Workspace designs
  * Think about not rolling up Page header actions

TODO 7/16
* (X) first-class toolbar for page presentation
  * does it need to be sticky?
* F6/Shift+F6 accessibility
  * https://www.w3.org/TR/wai-aria-practices-1.1/#keyboard-interaction-24
  * Might make sense to toggle between page/workspace? not much info otherwise
  * Might stomp on browser shortcuts: https://www.chromium.org/user-experience/keyboard-access
* include page header in main element
  * this is very hard with current layout design
  * ouch
  * Does main HAVE to overflow? Can we have a separate element handle the overflow (and thus maintain the current layout)
* Page-in-modal accessibility (main in modal => bad news bears)
* Accordion Side Navigation
* Routing prototype
* Investigate whether prop for optional navigable item persistance (hidden, not removed) makes sense
  * for DOM-sensitive elements like iframes

TODO 8/13
* Workpace layouts
* Side Nav integration with dev site tree view
* notification counts throughout

TODO 10/08
* Investigate whether prop for optional navigable item persistance (hidden, not removed) makes sense
  * for DOM-sensitive elements like iframes
  * Page/PrimaryNavigation/SecondaryNavigation 

  * Questions
    * Should elements that contain iframes hit the DOM immediately, even if hidden? Currently, only when they have become active once do we persist them
    * Any other elements to worry about here? (img)
    * Do we want to offer first-class "persist this" APIs so that individual items can be forced to remain in the DOM regardless of content? Likewise, do
      we offer a first-class "portal this" API to force elements to be portaled, regardless of content?

* (X) F6/Shift+F6 accessibility
  * https://www.w3.org/TR/wai-aria-practices-1.1/#keyboard-interaction-24
  * Might stomp on browser shortcuts: https://www.chromium.org/user-experience/keyboard-access
  * Switch between skip-to regions
  * Might also switch between other areas.
  * This seems like a no-go, as browsers use F6 to shift between page content, address bar, and bookmarks

* Move over orion-application Features
* ActiveComponentContext
  * Navigation, Page, and Layers
* BlockingOverlay styles
* PageHeader actions final API
* "Can Navigate"/"Is Modal Open" API (perhaps scope out)
* (X) Page disable actions when loading overlay is active
* (X) SessionContext
  * UserContext
  * SessionActionsContext
* (X) Discuss purpose and placement of Error Boundaries within the framework in general
  * Seems like a single error boundary is prudent
* Active Page Event Emitter
  * Investigate only doing so for non-modal pages

TODO 10/21
* (X) ActiveComponentContext
  * Navigation only
  * NavigationItemContext? <- Yes
* (X) EventEmitter.emit('terra-application.dismiss-transient-layers');
* (X) Notification counts in secondary nav
  * scoped out
* (X) Escape handling for workspace/sidenav overlay
* (X) Scroll persistance for generic Page content
* (X) Fallback nav item for Primary/SecondaryNavigationLayout
* (X) Move focus to workspace container after toggling it open
* (X) iframe support in nested page disclosure portals
* (X) renderPage/renderLayout/children
* (X) Remove dynamic title stuff
* (X) Active Page Event Emitter
  * Investigate only doing so for non-modal pages
  * need add unique key to each page (required or not)
  * need to trigger event every time Page becomes visible (through side nav or progressive disclosure)
  * only needs to happen within layout, not within modal
* (X) Remove isOpen prop from loading overlay
* (X) PageHeader actions final API
  * actions + menu (one page, no drill-in)

* Investigate Close and Escape implementation for modals
  * need to validate dropdowns/select 
* Sync up on F6 functionality
* Move over orion-application Features
* InteractionBlockOverlay styles/accessibility
  * Loading indicator? fade-in styles? Focusable? 
* "Can Navigate"/"Is Modal Open" API (perhaps scope out)
* think about scroll persistance with unmounting navigation content
  * would need to be more eager about caching scroll positions
* Menu API is busted for checkmarks